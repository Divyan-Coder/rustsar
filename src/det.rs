/// # Module: DET (Default Error Tracer)
///
/// This module provides functionality for error tracing and reporting in the AUTOSAR Classic Platform.
///
/// ## Description:
/// The DET module is responsible for capturing and reporting runtime errors that occur in the base software.
/// It adheres to the AUTOSAR specifications and ensures standardized error handling across modules.
///
/// ## AUTOSAR Details:
/// - **AUTOSAR Version:** R21-11
/// - **Classic Platform:** Yes
///
/// ## Version History:
/// ------------------------------------------------------------------------------------------------
/// | Version | Date       | Author         | Description                                           |
/// -----------------------------------------------------------------------------------------------
/// | 1.0.0   | 2023-10-01 | Divyan-coder   | Initial version of det.rs file.                       |
/// -----------------------------------------------------------------------------------------------
/// | 1.0.1   | 2023-10-02 | Divyan-coder   | Added initialization logic and removed Det structure  |
/// |         |            |                | and moved function to module level                    |
/// -----------------------------------------------------------------------------------------------
///
/// ## Notes:
/// - The DET module is designed to be lightweight and efficient for embedded systems.
/// - It is intended for use in environments where runtime error detection is critical.
/// - Ensure compatibility with the specified AUTOSAR version before integrating.
///
/// ## Implemented Requirements:
/// 
///
/// ## Not Implemented Requirements:
/// 


use crate::std_types::{StdReturnType, StdVersionInfoType};


// start of declarations
/// Structure to represent an error reported to DET
#[derive(Debug, Clone)]
pub struct DetError {
    pub module_id: u16,
    pub instance_id: u8,
    pub api_id: u8,
    pub error_id: u8,
}

#[derive(Debug)]
pub struct DetConfigType {

}

// Define the function pointer type for the error hook
pub type DetErrorHook = fn(module_id: u16, instance_id: u8, api_id: u8, error_id: u8) -> StdReturnType;
// end of declarations

// start of Global Variables
// Module-wide initialization flag
static mut DET_INITIALIZED: bool = false;
// end of Global Variables

/*
This array will be generated by the configuration tool
For now, it's an empty array (skeleton)
## Implemented Requirements:
   SWS_Det_00207
*/
static DET_ERRORHOOKS: &[DetErrorHook] = &[];
static DET_RUNTIME_ERRORHOOKS: &[DetErrorHook] = &[];
static DET_TRANSIENT_FAULT_HOOKS: &[DetErrorHook] = &[];

/*
Initialize the DET module

## Implemented Requirements:
    SWS_Det_00019
    SWS_Det_00020
## Not Implemented Requirements:

*/
pub fn init(config_ptr: &DetConfigType){
    // Set the module-wide initialization flag to true
    unsafe {
        DET_INITIALIZED = true;
    }
    println!("Init configPtr = {:?}, DET initialized", config_ptr);
}

pub fn is_initialized() -> bool {
    unsafe { DET_INITIALIZED }
}

/// ## Implemented Requirements:
///     SWS_Det_00025
/// ## Not Implemented Requirements:
/// 
pub fn start() {
    // Initialization logic for DET can be added here
    println!("DET started");
}

/// Report an error to DET
/// ## Implemented Requirements:
///     SWS_Det_00019
///     SWS_Det_00020
///     SWS_Det_00024
///     SWS_Det_00208
///     SWS_Det_00014
///     SWS_Det_00018
///     SWS_Det_00015
///     SWS_Det_00035
/// ## Not Implemented Requirements:
///     SWS_Det_00034
///     SWS_Det_00039
///     SWS_Det_00026
pub fn report_error(module_id: u16, instance_id: u8, api_id: u8, error_id: u8) -> StdReturnType {
    if !is_initialized() {
        // SWS_Det_00208: Do nothing, return immediately
        return StdReturnType::Ok;
    }

    let error = DetError {
        module_id,
        instance_id,
        api_id,
        error_id,
    };

    for hook in DET_ERRORHOOKS {
        hook(module_id, instance_id, api_id, error_id);
    }
    // SRS_BSW_00337 : abort the normal flow and trigger a reset
    // This is a placeholder for the actual error handling logic
    panic!("DET Error Reported: {:?}", error);

    StdReturnType::Ok
}

/// Report an runtime error to DET
/// ## Implemented Requirements:
///     SWS_Det_00019
///     SWS_Det_00024
///     SWS_Det_00208
///     SWS_Det_00014
///     SWS_Det_00018
///     SWS_Det_00015
///     SWS_Det_00035
/// ## Not Implemented Requirements:
///     SWS_Det_00034
///     SWS_Det_00039
///     SWS_Det_00026
pub fn report_runtime_error(module_id: u16, instance_id: u8, api_id: u8, error_id: u8)->StdReturnType {
    let mut ret: StdReturnType = StdReturnType::Ok;

    if is_initialized() == false {
        // SWS_Det_00208: Do nothing, return immediately
        ret = StdReturnType::Ok;
    } else{
        let runtime_error = DetError {
            module_id,
            instance_id,
            api_id,
            error_id,
        };

        // Call all configured error hooks (if any)
        for hook in DET_RUNTIME_ERRORHOOKS {
            hook(module_id, instance_id, api_id, error_id);
        }
        // Log the error (for debugging purposes)
        println!("DET Error Reported: {:?}", runtime_error);
    }
    ret
}

/// Report a transient fault to DET
/// ## Implemented Requirements:
///     SWS_Det_00024
///     SWS_Det_00208
///     SWS_Det_00014
///     SWS_Det_00018
///     SWS_Det_00015
///     SWS_Det_00035
/// ## Not Implemented Requirements:
///     SWS_Det_00034
///     SWS_Det_00039
///     SWS_Det_00026
pub fn report_transient_fault(module_id: u16, instance_id: u8, api_id: u8, error_id: u8) -> StdReturnType{
    let mut ret: StdReturnType = StdReturnType::Ok;

    if is_initialized() == false {
        // SWS_Det_00208: Do nothing, return immediately
        ret = StdReturnType::Ok;
    } else {
        let transient_fault = DetError {
            module_id,
            instance_id,
            api_id,
            error_id,
        };

        // Call all configured error hooks (if any)
        for hook in DET_TRANSIENT_FAULT_HOOKS {
            hook(module_id, instance_id, api_id, error_id);
        }
        // Log the error (for debugging purposes)
        println!("DET Transient Fault Reported: {:?}", transient_fault);

    }
    ret
}

/// ## Implemented Requirements:
///     SWS_Det_00019
/// ## Not Implemented Requirements:
/// 
pub fn get_version_info() -> StdVersionInfoType {
    // Return the version information for DET
    StdVersionInfoType {
        vendor_id: 0x0001,  // Rustsar vender ID
        sw_major_version: 0x01, // Major version
        sw_minor_version: 0x00, // Minor version
        sw_patch_version: 0x00, // Patch version
    }
}

#[cfg(test)]
mod tests {
    use super::*;

     // Shadow the static for testing
    static mut DET_ERRORHOOKS: &[DetErrorHook] = &[];
    static mut DET_RUNTIME_ERRORHOOKS: &[DetErrorHook] = &[];
    static mut DET_TRANSIENT_FAULT_HOOKS: &[DetErrorHook] = &[];

    // Helper to reset DET_INITIALIZED for tests
    fn reset_det() {
        unsafe { DET_INITIALIZED = false; }
    }

    #[test]
    fn test_init_sets_initialized() {
        reset_det();
        let config = DetConfigType {};
        init(&config);
        assert!(is_initialized());
    }

    #[test]
    fn test_is_initialized_false_by_default() {
        reset_det();
        assert!(!is_initialized());
    }

    #[test]
    fn test_report_error_not_initialized() {
        reset_det();
        let result = report_error(1, 2, 3, 4);
        assert_eq!(result, StdReturnType::Ok);
    }

    #[test]
    #[should_panic(expected = "DET Error Reported")]
    fn test_report_error_calls_hooks_and_panics_when_initialized() {
        reset_det();
        init(&DetConfigType {});
        static mut CALLED: bool = false;
        fn test_hook(_m: u16, _i: u8, _a: u8, _e: u8) -> StdReturnType {
            unsafe { CALLED = true; }
            StdReturnType::Ok
        }
        unsafe {
            DET_ERRORHOOKS = &[test_hook];
        }
        let _ = report_error(1, 2, 3, 4);
        unsafe { assert!(CALLED); }
    }

    #[test]
    fn test_report_runtime_error_not_initialized() {
        reset_det();
        let result = report_runtime_error(1, 2, 3, 4);
        assert_eq!(result, StdReturnType::Ok);
    }

    #[test]
    fn test_report_runtime_error_calls_hooks_when_initialized() {
        reset_det();
        init(&DetConfigType {});
        static mut CALLED: bool = false;
        fn test_hook(_m: u16, _i: u8, _a: u8, _e: u8) -> StdReturnType {
            unsafe { CALLED = true; }
            StdReturnType::Ok
        }
        // Patch DET_RUNTIME_ERRORHOOKS for this test
        unsafe {
            DET_RUNTIME_ERRORHOOKS = &[test_hook];
        }
        let _ = report_runtime_error(1, 2, 3, 4);
        unsafe { assert!(CALLED); }
    }

    #[test]
    fn test_report_transient_fault_not_initialized() {
        reset_det();
        let result = report_transient_fault(1, 2, 3, 4);
        assert_eq!(result, StdReturnType::Ok);
    }

    #[test]
    fn test_report_transient_fault_calls_hooks_when_initialized() {
        reset_det();
        init(&DetConfigType {});
        static mut CALLED: bool = false;
        fn test_hook(_m: u16, _i: u8, _a: u8, _e: u8) -> StdReturnType {
            unsafe { CALLED = true; }
            StdReturnType::Ok
        }
        // Patch DET_TRANSIENT_FAULT_HOOKS for this test
        unsafe {
            DET_TRANSIENT_FAULT_HOOKS = &[test_hook];
        }
        let _ = report_transient_fault(1, 2, 3, 4);
        unsafe { assert!(CALLED); }
    }

    #[test]
    fn test_get_version_info() {
        let info = get_version_info();
        assert_eq!(info.vendor_id, 0x0001);
        assert_eq!(info.sw_major_version, 0x01);
        assert_eq!(info.sw_minor_version, 0x00);
        assert_eq!(info.sw_patch_version, 0x00);
    }
}

